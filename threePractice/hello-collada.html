


<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>3D Fortify</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.js-master/build/three.min.js"></script>
		<script src="meshline/THREE.MeshLine.js"></script>
		<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>
		<script src="three.js-master/examples/js/controls/TrackballControls.js"></script>
		<script src="three.js-master/examples/js/loaders/ColladaLoader.js"></script>
		<script>

var scene,
    camera,
    renderer,
    controls;

scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera( 5, window.innerWidth / window.innerHeight, 1, 1000 );
camera.position.set(-6, -6, 4);
camera.up.y = 0;
camera.up.z = 1;
camera.lookAt( scene.position );

renderer = new THREE.WebGLRenderer({
 	alpha: true,
    antialias: true
});
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setClearColor( 0x333344, 1 );

document.body.appendChild( renderer.domElement );


/////////////////////////////////////////
// Trackball Controller
/////////////////////////////////////////

controls = new THREE.TrackballControls( camera );
controls.rotateSpeed = 5.0;
controls.zoomSpeed = 3.2;
controls.panSpeed = 0.8;
controls.noZoom = false;
controls.noPan = true;
controls.staticMoving = false;
controls.dynamicDampingFactor = 0.2;


/////////////////////////////////////////
// Lighting
/////////////////////////////////////////

var iphone_color  = '#FAFAFA',
    ambientLight  = new THREE.AmbientLight( '#EEEEEE' ),
    hemiLight     = new THREE.HemisphereLight( iphone_color, iphone_color, 0 ),
    light         = new THREE.PointLight( iphone_color, 1, 100 );

hemiLight.position.set( 0, 50, 0 );
light.position.set( 0, 20, 10 );

scene.add( ambientLight );
scene.add( hemiLight );
scene.add( light );


/////////////////////////////////////////
// Utilities
/////////////////////////////////////////

var axisHelper = new THREE.AxesHelper( 1 );
scene.add( axisHelper );


/////////////////////////////////////////
// Render Loop
/////////////////////////////////////////

function render() {
  renderer.render( scene, camera );
}

// Render the scene when the controls have changed.
// If you don’t have other animations or changes in your scene,
// you won’t be draining system resources every frame to render a scene.
// controls.addEventListener( 'change', render );


// Avoid constantly rendering the scene by only
// updating the controls every requestAnimationFrame
function animationLoop() {
  requestAnimationFrame(animationLoop);

  if (meshCurve) {
	  meshCurve.rotation.z += .01;
  }

  controls.update();
  render();
}

animationLoop();


/////////////////////////////////////////
// Window Resizing
/////////////////////////////////////////

window.addEventListener( 'resize', function () {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
    controls.handleResize();
    render();
}, false );


function createCurve() {

	var curve = new THREE.EllipseCurve(
		.5,  0,            // ax, aY
		.5, .75,           // xRadius, yRadius
		0,  2 * Math.PI,  // aStartAngle, aEndAngle
		false,            // aClockwise
		0                 // aRotation
	);

	var points = curve.getPoints( 50 );
	var geometry = new THREE.BufferGeometry().setFromPoints( points );

	var material = new THREE.LineBasicMaterial( {
		color : 0xff0000,
	 	linewidth : 12
	} );

	// Create the final object to add to the scene
	var ellipse = new THREE.Line( geometry, material );
	return ellipse;
}

// cfg = { x:1, y:1, r:1}
function createMeshCurve(cfg) {
	var geometry = new THREE.Geometry();

	var rad = cfg.r;
	var xoff = 0;
	var yoff = 0;
	for( var j = 0; j < 2*Math.PI; j += 2 * Math.PI / 100 ) {
		var v = new THREE.Vector3( rad* Math.cos( j )+xoff, rad*Math.sin( j )+yoff, 0 );
		geometry.vertices.push( v );
	}

	var line = new MeshLine();
	line.setGeometry( geometry, function(d) { return .05 + .03*Math.sin(50 * d); } );

	var material = new MeshLineMaterial();
	var mesh = new THREE.Mesh( line.geometry, material );

	mesh.position.x += cfg.x;
	mesh.position.y += cfg.y;

	return mesh;
}

/////////////////////////////////////////
// Object Loader
/////////////////////////////////////////

var dae,
    loader = new THREE.ColladaLoader();

function loadLeftCoil( collada ) {
	dae = collada.scene;
	dae.position.set(0.3, 0, 0);

	dae.scale.x = .1;
	dae.scale.y = .1;
	dae.scale.z = .1;

	scene.add(dae);
	render();
}

function loadRightCoil( collada ) {

	return loadCoil(collada, {x: 0, y:0, z:0});
}

function loadPlasticBox( collada ) {

  	dae = collada.scene;

//  dae.rotation.z += 3.14/2;
	dae.scale.x = .1;
	dae.scale.y = .1;
	dae.scale.z = .25;

	dae.rotation.x += 3.14/2;
    dae.position.set(-4.2, -3.1, -.2);

	scene.add(dae);
	render();
}

function loadCoil (collada, pos) {
	dae = collada.scene;

	dae.rotation.y += 3.14/2;
	dae.position.set(pos.x, pos.y, pos.z);

	dae.scale.x = .1;
	dae.scale.y = .1;
	dae.scale.z = .1;

	scene.add(dae);
	return dae;
}

//loader.options.convertUpAxis = true;
loader.load( 'collada/toroidal-Inductor.dae', loadLeftCoil);
loader.load( 'collada/toroidal-Inductor.dae', loadRightCoil);

//loader.load( 'collada/skp-simple-plastic-box/model.dae', loadPlasticBox);

//var curve = createCurve();
//scene.add(curve);

var meshCurve = createMeshCurve({x:.3, y:-.3, r:.2});
scene.add(meshCurve);
render();


</script>
</body>
</html>
